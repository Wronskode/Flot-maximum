\documentclass[a4paper]{article}

% Options possibles : 10pt, 11pt, 12pt (taille de la fonte)
%                     oneside, twoside (recto simple, recto-verso)
%                     draft, final (stade de développement)

\usepackage[utf8]{inputenc}   % LaTeX, comprends les accents !
\usepackage[T1]{fontenc}      % Police contenant les caractères français
\usepackage{fontspec} % Pour les accents de Tomáš Kaiser
\usepackage[french]{babel}  
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning}
\usepackage{titling}
\usepackage{float}
\usepackage{tikz-uml}
\usepackage{pgf-umlsd}
\usepackage{tikz}
\definecolor{myblue}{RGB}{85,114,193}
\tikzset{Dotted/.style={
    line width=1pt,
    dash pattern=on 0.01\pgflinewidth off #1\pgflinewidth,line cap=round,
    shorten >=0.3em,shorten <=0.3em},
    Dotted/.default=5}
\usetikzlibrary{arrows.meta,calc,positioning,shapes,arrows}
%\usepackage{pdflscape}
\usepackage{geometry}
\usepackage{biblatex}
\usepackage{graphicx} % Required for inserting images
\usepackage[colorlinks=true ,urlcolor=blue,urlbordercolor={0 1 1}]{hyperref}
\usepackage{float}
\usepackage{amssymb}
\usepackage{amsthm} 
\usepackage{amsmath} 
\usepackage{datetime}
\usepackage{numprint}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\small,
  frame=single,
  columns=fullflexible
}
%\usepackage{fullpage}
\addbibresource{sample.bib}
%\usepackage{minitoc}
\makeatletter
\makeatother
\newdate{frontpagedate}{10}{05}{2025} 
\begin{document}
\pagenumbering{gobble} 
\begin{center}
\vspace{2cm}
%\textsc{ Oregon State University}\\[1.5cm]
\includegraphics[width=0.4\textwidth]{UM1.jpg}~\\[1cm]
\vspace{2cm}

% Title
\hrule
\vspace{.5cm}
{\huge\bfseries{Résolution du problème du flot maximum\par}} % title of the report
\vspace{.5cm}

\hrule
\vspace{1.5cm}

\textsc{\textbf{Auteurs}}\\
\vspace{.5cm}
\centering

% add your name here
Cédric Audie\\
Marie Dalenc\\
Julien Lahoz\\
Adrien Martinelli


\vspace{1cm}

\textsc{\textbf{Encadrant}}\\
\vspace{.5cm}
\centering

% add your name here
Rodolphe Giroudeau

\vspace{4cm}

\centering \displaydate{frontpagedate} % Dags dato
\end{center}
\newpage
{\hypersetup{hidelinks}
\tableofcontents
}
\pagenumbering{arabic}  
\newpage
\section{Introduction}

Le problème du flot maximum est l’un des problèmes fondamentaux en algorithmique et en recherche opérationnelle. Il consiste à trouver, dans un réseau orienté avec des capacités sur les arcs, le flot de valeur maximale entre une source et un puits, tout en respectant les contraintes de capacité et de conservation des flots.

Depuis plusieurs décennies, de nombreux algorithmes ont été développés pour résoudre ce problème, parmi lesquels on compte les méthodes classiques comme Ford-Fulkerson, Edmonds-Karp ou encore Dinic, mais aussi des approches basées sur la programmation linéaire. Ces algorithmes diffèrent à la fois par leur complexité théorique, leur comportement pratique et leur adaptabilité à différents types de graphes.

L’objectif de ce travail est de comparer ces différentes méthodes de résolution, à la fois sur le plan théorique et expérimental. Nous mettrons en \oe uvre ces algorithmes, puis les testerons sur des jeux d’essais variés pour évaluer leurs performances respectives.

Ce rapport est structuré comme suit : après une présentation des méthodes considérées, nous décrivons notre méthodologie expérimentale, puis nous analysons les résultats obtenus avant de conclure sur les perspectives ouvertes par ce travail.
\subsection{Présentation détaillée du problème de flot maximum}
Le problème du flot maximum se définit sur un graphe orienté $G = (V, E)$, où $V$ est l’ensemble des sommets et $E$ l’ensemble des arcs. Chaque arc $(u, v) \in E$ est associé à une capacité $c(u, v) \geq 0$, représentant la quantité maximale de flot qui peut circuler de $u$ vers $v$. Si $(u, v)\notin E$, on suppose que $c(u, v) = 0$. On désigne par $s \in V$ la source et par $t \in V$ le puits, avec $s \neq t$.

Un \emph{flot} est une fonction $f : V^2 \to \mathbb{R}$ qui satisfait les contraintes suivantes :
\begin{itemize}
    \item \textbf{Capacité} : $\forall (u, v) \in V^2,\ 0 \leq f(u, v) \leq c(u, v)$ ;
    \item \textbf{Anti-symétrie} : $\forall (u, v) \in V^2,\ f(u, v) = -f(v, u)$ ;
    \item \textbf{Conservation} : $\forall v \in V \setminus \{s, t\},\ \sum_{(u, v) \in E} f(u, v) = \sum_{(v, z) \in E} f(v, z)$, c’est-à-dire que tout sommet intermédiaire conserve le flot (pas de perte ni de création de matière) ;
    \item \textbf{Valeur du flot} : la quantité totale envoyée par la source est $|f| = \sum_{v \in V} f(s, v)$, et c’est cette valeur que l’on cherche à maximiser.
\end{itemize}

On appelle \emph{réseau de flot} un quadruplet $(G, s, t, c)$, où :
\begin{itemize}
    \item $G = (V,E)$ est un graphe orienté,
    \item $s \in V$ est la source,
    \item $t \in V$ est le puits ($s \neq t$),
    \item $c : V^2 \to \mathbb{R}^+$ est une fonction de capacité sur les arcs, et qui est nulle si l’arc n’existe pas.
\end{itemize}
Le problème du flot maximum consiste donc à trouver un flot $f$ respectant les contraintes ci-dessus et maximisant $|f|$. Dans notre cas particulier, nous allons nous intéresser à des graphes orientés avec un flot entier et des capacités entières.

\paragraph{Applications :} Le flot maximum possède de nombreuses applications concrètes : planification logistique, réseaux de transport (par exemple pour maximiser le trafic dans un réseau routier), routage dans les réseaux de communication, allocation de ressources, et même en algorithmique pour résoudre d’autres problèmes puisque le problème du flot maximum est \textsc{P-complet}. C'est-à-dire qu'il se résout en temps polynomial, et que tout problème polynomial peut s'y réduire par une réduction en espace logarithmique.
\subsection{Exemple}
% \textit{Faire un exemple illustratif}
\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[
			vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
			every edge/.style={draw, ->, thick}, % Ajout de flèches
			->,>=stealth % Style explicite de flèches (stealth' pour une tête nette)
			]

			% Les sommets
			\node[vertex] (S) at (0.5, 1) {S};
			\node[vertex] (A) at (2, 2) {A};
			\node[vertex] (B) at (4, 2) {B};
			\node[vertex] (C) at (2, 0) {C};
			\node[vertex] (D) at (4, 0) {D};
			\node[vertex] (P) at (5.5, 1) {P};
				
			% Les arêtes orientées
			%\draw[->, bend left=15] (A) to (B);
			\draw[->] (S) to node[midway, above left] {\textcolor{red}{2}/4} (A);
			\draw[->] (S) to node[midway, below left] {\textcolor{red}{0}/3} (C);
			\draw[->] (A) to node[midway, above] {\textcolor{red}{2}/3} (B);
			\draw[->] (A) to node[midway, left] {\textcolor{red}{0}/2} (C);
			\draw[->] (B) to node[midway, right] {\textcolor{red}{1}/3} (D);
			\draw[->] (B) to node[midway, above right] {\textcolor{red}{1}/2} (P);
			\draw[->] (C) to node[midway, below] {\textcolor{red}{0}/2} (D);
			\draw[->] (D) to node[midway, below left] {\textcolor{red}{0}/1} (A);
			\draw[->] (D) to node[midway, below right] {\textcolor{red}{1}/4} (P);
		\end{tikzpicture}
		\caption{Exemple de réseau de flot, avec en \textcolor{red}{\textbf{rouge}} un flot et en \textbf{noir} la capacité de chaque arc.}
	\end{center}
\end{figure}

Dans cet exemple, le sommet $A$ reçoit deux unités depuis la source et les envoies au sommet $B$. Le sommet $B$ redistribue ce flot vers les sommets $D$ et $P$. La valeur du flot est de $2$, c'est la somme des flots sortants de la source $S$ (et également la somme des flots entrants dans le puits). 
\section{Définitions générales}
\subsection{Réseau résiduel}
Soit $G$ un graphe avec $s$, $p$ et $c$ respectivement la source, le puits et la fonction de capacité associés au graphe $G$. Notons $N = (G,s,p,c)$ un réseau de flot dans $G$ avec un flot $f$.\\
Le réseau résiduel de $N$ et d'un flot $f$, noté $N_f$, est construit de la manière suivante :\\
Pour chaque arc $xy$ de $G$ :
\begin{itemize}
	\item
    Si $f(xy)<c(xy)$, on crée un arc $xy$ dans $G'$ avec la quantité restante disponible de la capacité: $c'(xy) = c(xy) - f(xy)$.
    \item 
    Si $f(xy)>0$ avec $x\ne s$ et $y\ne p$, on crée un arc $yx$ dans $G'$ avec la capacité qu'on peut réaiguiller : $c'(yx) = f(xy)$.
\end{itemize}
Ceci nous donne $N_f = (G',s,p,c')$.\\
\subsection{Chemin et flot améliorants}
\begin{itemize}
	\item
    Un chemin améliorant pour $N$ et $f$ est un chemin de $s$ à $p$ dans la réseau résiduel $N_f$.
    \item
    Soit $C = x_0,x_1,...,x_k$ un chemin améliorant dans $N_f$, le flot améliorant correspondant est :
$f'(xy) = \left\{
    \begin{array}{ll}
        \gamma & \mbox{si } xy \mbox{ est un arc de C} \\
        0 & \mbox{sinon.}
    \end{array}
\right.$
avec $\gamma = \min \{c'(x_ix_{i+1}); i \in [\![0;k-1]\!]\}$\\
\end{itemize}
\section{Différents algorithmes et exemple}
Nous prendrons l'exemple suivant pour illustrer les différents algorithmes :

\begin{center}
\begin{tikzpicture}[
	vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
	every edge/.style={draw, ->, thick}, % Ajout de flèches
	->,>=stealth % Style explicite de flèches (stealth' pour une tête nette)
	]

	% Les sommets
    \node[vertex] (S) at (0.5, 1) {S};
    \node[vertex] (A) at (2, 2) {A};
	\node[vertex] (B) at (4, 2) {B};
	\node[vertex] (C) at (2, 0) {C};
	\node[vertex] (D) at (4, 0) {D};
	\node[vertex] (P) at (5.5, 1) {P};
		
	% Les arêtes orientées
	%\draw[->, bend left=15] (A) to (B);
    \draw[->] (S) to node[midway, above left] {4} (A);
    \draw[->] (S) to node[midway, below left] {3} (C);
	\draw[->] (A) to node[midway, above] {3} (B);
	\draw[->] (A) to node[midway, left] {2} (C);
    \draw[->] (B) to node[midway, right] {3} (D);
	\draw[->] (B) to node[midway, above right] {2} (P);
	\draw[->] (C) to node[midway, below] {2} (D);
    \draw[->] (D) to node[midway, below left] {1} (A);
    \draw[->] (D) to node[midway, below right] {4} (P);
\end{tikzpicture}\end{center}


\subsection{L'algorithme de Ford-Fulkerson}

\subsubsection{Fonctionnement général}
L'algorithme de Ford-Fulkerson est le plus connu parmi tous. Celui-ci consiste à trouver un chemin améliorant entre la source et le puits afin d'augmenter la valeur du flot. Pour cela nous aurons besoin du graphe résiduel de $G$ et $f$ qui nous permettra de savoir les capacités restantes disponibles.\\

\subsubsection{Algorithme}
Pour tout arc $xy$ du graphe $G$: on initialise la valeur du flot de $xy$ à $0$.\\
Tant qu'il existe un chemin améliorant $C$ dans le graphe résiduel de $G$ et $f$:
\begin{itemize}
	\item
    Calculer le flot améliorant $f'$ correspondant.
    \item 
    Augmenter $f$ par $f'$
\end{itemize}
Retourner $f$.\\

\subsubsection{Complexité}

\subsubsection{Avantages/inconvénients}

\subsubsection{Application sur l'exemple}
Tout d'abord, on a le chemin améliorant : $SABP$ avec une valeur de flot améliorant égal à $2$.\\
On obtient donc à droite le réseau résiduel $N_f$ :

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={draw, ->, thick},
		->,>=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};

		\draw[highlight] (S) -- (A);
		\draw[highlight] (A) -- (B);
		\draw[highlight] (B) -- (P);
	
		\draw[->] (S) to node[midway, above left] {2/4} (A);
		\draw[->] (S) to node[midway, below left] {3} (C);
		\draw[->] (A) to node[midway, above] {2/3} (B);
		\draw[->] (A) to node[midway, left] {2} (C);
		\draw[->] (B) to node[midway, right] {3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {4} (P);
	
		% --- Deuxième graphe (à droite), décalé de +7 en x ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		\draw[->] (S2) to node[midway, above left] {2} (A2);
		\draw[->] (S2) to node[midway, below left] {3} (C2);
		\draw[->, bend left=15] (A2) to node[midway, above] {1} (B2);
		\draw[->] (A2) to node[midway, left] {2} (C2);
		\draw[->, bend left=15] (B2) to node[midway, below] {2} (A2);
		\draw[->] (B2) to node[midway, right] {3} (D2);
		\draw[->] (C2) to node[midway, below] {2} (D2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->] (D2) to node[midway, below right] {4} (P2);
	
	\end{tikzpicture}
	\end{center}
	


On voit qu'il y a le chemin améliorant $SACDP$ avec un flot améliorant égal à $2$.\\
On obtient à droite le nouveau réseau résiduel $N_f$ :

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={draw, ->, thick},
		->, >=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};

		\draw[highlight] (S) -- (A);
		\draw[highlight] (A) -- (C);
		\draw[highlight] (C) -- (D);
		\draw[highlight] (D) -- (P);
	
		\draw[->] (S) to node[midway, above left] {4/4} (A);
		\draw[->] (S) to node[midway, below left] {3} (C);
		\draw[->] (A) to node[midway, above] {2/3} (B);
		\draw[->] (A) to node[midway, left] {2/2} (C);
		\draw[->] (B) to node[midway, right] {3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2/2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {2/4} (P);
	
		% --- Deuxième graphe (à droite), décalé de +7 en x ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		\draw[->] (S2) to node[midway, below left] {3} (C2);
		\draw[->, bend left=15] (A2) to node[midway, above] {1} (B2);
		\draw[->, bend left=15] (B2) to node[midway, below] {2} (A2);
		\draw[->] (B2) to node[midway, right] {3} (D2);
		\draw[->] (C2) to node[midway, right] {2} (A2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->] (D2) to node[midway, above] {2} (C2);
		\draw[->] (D2) to node[midway, below right] {2} (P2);
	
	\end{tikzpicture}
\end{center}

On voit qu'il y a le chemin améliorant $SCABDP$ avec un flot améliorant égal à $1$.\\
On obtient à droite le nouveau réseau résiduel $N_f$ :

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={draw, ->, thick},
		->,>=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};

		\draw[highlight] (S) -- (C);
		\draw[highlight] (C) -- (A);
		\draw[highlight] (A) -- (B);
		\draw[highlight] (B) -- (D);
		\draw[highlight] (D) -- (P);
	
		\draw[->] (S) to node[midway, above left] {4/4} (A);
		\draw[->] (S) to node[midway, below left] {1/3} (C);
		\draw[->] (A) to node[midway, above] {3/3} (B);
		\draw[->] (A) to node[midway, left] {1/2} (C);
		\draw[->] (B) to node[midway, right] {1/3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2/2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {3/4} (P);
	
		% --- Deuxième graphe (à droite), décalé de +7 en x ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		\draw[->] (S2) to node[midway, below left] {2} (C2);
		\draw[->, bend right=15] (A2) to node[midway, left] {1} (C2);
		\draw[->] (B2) to node[midway, below] {3} (A2);
		\draw[->, bend left=15] (B2) to node[midway, right] {2} (D2);
		\draw[->, bend right=15] (C2) to node[midway, right] {1} (A2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->, bend left=15] (D2) to node[midway, left] {1} (B2);
		\draw[->] (D2) to node[midway, above] {2} (C2);
		\draw[->] (D2) to node[midway, below right] {1} (P2);
	
	\end{tikzpicture}
	\end{center}
	

Dans ce dernier réseau résiduel, si nous partons de la source $S$ nous ne pouvons atteindre que les sommets $A$ et $C$. Comme nous ne pouvons plus atteindre le puits $P$, cela signifie que le flot obtenu est maximal.\\
Finalement la coupe minimale de ce réseau est l'ensemble $\{S,A,C\}$ et son flot maximal est de valeur $5$.\\

\subsection{L'algorithme d'Edmonds-Karp}

\subsubsection{Fonctionnement général}
L'algorithme d'Edmonds-Karp est une spécificité de celui de Ford-Fulkerson. Celui-ci consiste à trouver le plus court chemin améliorant entre la source et le puits afin d'augmenter la valeur du flot. Pour le trouver, il suffit d'utiliser un parcours en largeur.\\

\subsubsection{Algorithme}
Pour tout arc $xy$ du graphe $G$: on initialise la valeur du flot de $xy$ à $0$.\\
Tant qu'il existe un plus court chemin améliorant $C$ dans le graphe résiduel de $G$ et $f$:
\begin{itemize}
	\item
    Calculer le flot améliorant $f'$ correspondant.
    \item 
    Augmenter $f$ par $f'$
\end{itemize}
Retourner $f$.\\

\subsubsection{Complexité}

\subsubsection{Avantages/inconvénients}

\subsubsection{Application sur l'exemple}
Tout d'abord, on a le chemin améliorant : $SABP$ de taille $4$ avec une valeur de flot améliorant égal à $2$.\\
On obtient donc à droite le réseau résiduel $N_f$ :

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};
	
		% Arcs surlignés (avec /)
		\draw[highlight] (S) -- (A);
		\draw[highlight] (A) -- (B);
		\draw[highlight] (B) -- (P);
	
		% Arcs normaux
		\draw[->] (S) to node[midway, above left] {2/4} (A);
		\draw[->] (S) to node[midway, below left] {3} (C);
		\draw[->] (A) to node[midway, above] {2/3} (B);
		\draw[->] (A) to node[midway, left] {2} (C);
		\draw[->] (B) to node[midway, right] {3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {4} (P);
	
		% --- Deuxième graphe (à droite), décalé ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		% Aucun surlignage nécessaire ici
		\draw[->] (S2) to node[midway, above left] {2} (A2);
		\draw[->] (S2) to node[midway, below left] {3} (C2);
		\draw[->, bend left=15] (A2) to node[midway, above] {1} (B2);
		\draw[->] (A2) to node[midway, left] {2} (C2);
		\draw[->, bend left=15] (B2) to node[midway, below] {2} (A2);
		\draw[->] (B2) to node[midway, right] {3} (D2);
		\draw[->] (C2) to node[midway, below] {2} (D2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->] (D2) to node[midway, below right] {4} (P2);
	
	\end{tikzpicture}
	\end{center}
	


On voit qu'il y a le chemin améliorant $SACDP$ de taille $5$ avec un flot améliorant égal à $2$. Regardons si on trouve un chemin améliorant plus petit, le chemin $SCDP$ est un autre chemin améliorant de taille $4$ avec un flot améliorant égal à $2$. C'est ce chemin que nous choisissons.\\
On obtient à droite le nouveau réseau résiduel $N_f$ :


\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};
	
		% Arcs surlignés
		\draw[highlight] (S) -- (C);
		\draw[highlight] (C) -- (D);
		\draw[highlight] (D) -- (P);
	
		% Arcs normaux
		\draw[->] (S) to node[midway, above left] {2/4} (A);
		\draw[->] (S) to node[midway, below left] {2/3} (C);
		\draw[->] (A) to node[midway, above] {2/3} (B);
		\draw[->] (A) to node[midway, left] {2} (C);
		\draw[->] (B) to node[midway, right] {3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2/2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {2/4} (P);
	
		% --- Deuxième graphe (à droite), décalé de +7 ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		% Arcs normaux
		\draw[->] (S2) to node[midway, above left] {2} (A2);
		\draw[->] (S2) to node[midway, below left] {1} (C2);
		\draw[->, bend left=15] (A2) to node[midway, above] {1} (B2);
		\draw[->] (A2) to node[midway, left] {2} (C2);
		\draw[->, bend left=15] (B2) to node[midway, below] {2} (A2);
		\draw[->] (B2) to node[midway, right] {3} (D2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->] (D2) to node[midway, above] {2} (C2);
		\draw[->] (D2) to node[midway, below right] {2} (P2);
	
	\end{tikzpicture}
	\end{center}
	


Il n'y a plus de chemin améliorant de taille $4$ allant de $S$ à $P$. On va choisir un chemin améliorant de taille $5$ : $SABDP$ avec un flot améliorant égal à $1$.\\
Nous obtenons à droite le nouveau réseau résiduel $N_f$ :


\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		highlight/.style={->, line width=3pt, draw=green!100},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% --- Premier graphe (à gauche) ---
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};
	
		% Arcs surlignés
		\draw[highlight] (S) -- (A);
		\draw[highlight] (A) -- (B);
		\draw[highlight] (B) -- (D);
		\draw[highlight] (D) -- (P);
	
		% Arcs normaux
		\draw[->] (S) to node[midway, above left] {3/4} (A);
		\draw[->] (S) to node[midway, below left] {2/3} (C);
		\draw[->] (A) to node[midway, above] {3/3} (B);
		\draw[->] (A) to node[midway, left] {2} (C);
		\draw[->] (B) to node[midway, right] {1/3} (D);
		\draw[->] (B) to node[midway, above right] {2/2} (P);
		\draw[->] (C) to node[midway, below] {2/2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {3/4} (P);
	
		% --- Deuxième graphe (à droite), décalé de +7 ---
		\node[vertex] (S2) at ($(S)+(6,0)$) {S};
		\node[vertex] (A2) at ($(A)+(6,0)$) {A};
		\node[vertex] (B2) at ($(B)+(6,0)$) {B};
		\node[vertex] (C2) at ($(C)+(6,0)$) {C};
		\node[vertex] (D2) at ($(D)+(6,0)$) {D};
		\node[vertex] (P2) at ($(P)+(6,0)$) {P};
	
		% Arcs normaux
		\draw[->] (S2) to node[midway, above left] {1} (A2);
		\draw[->] (S2) to node[midway, below left] {1} (C2);
		\draw[->] (A2) to node[midway, left] {2} (C2);
		\draw[->] (B2) to node[midway, below] {3} (A2);
		\draw[->, bend left=15] (B2) to node[midway, right] {2} (D2);
		\draw[->] (D2) to node[midway, below left] {1} (A2);
		\draw[->, bend left=15] (D2) to node[midway, left] {1} (B2);
		\draw[->] (D2) to node[midway, above] {2} (C2);
		\draw[->] (D2) to node[midway, below right] {1} (P2);
	
	\end{tikzpicture}
	\end{center}
	


Dans ce dernier réseau résiduel, si nous partons de la source $S$ nous ne pouvons atteindre que les sommets $A$ et $C$. Comme nous ne pouvons plus atteindre le puits $P$, cela signifie que le flot obtenu est maximal.\\
Finalement la coupe minimale de ce réseau est l'ensemble $\{S,A,C\}$ et son flot maximal est de valeur $5$.\\

\subsection{L'algorithme de Dinic}

\subsubsection{Fonctionnement général}
L'algorithme de Dinic est semblable à celui d'Edmonds-Karp. Comme lui, il utilise des plus courts chemins améliorants entre la source et le puits afin d'augmenter la valeur du flot. \\Pour les trouver, il faudra étiqueter les sommets en fonction de leur distance par rapport à la source et garder les arcs qui relient un sommet à un sommet de distance immédiatement supérieure. Ceci nous donnera le réseau de niveau $N_L$ obtenu à partir du réseau résiduel $N_f$.\\
Nous aurons également besoin du flot bloquant. Il est défini comme suit : un flot est bloquant si $\forall C$ chemin entre la source et le puits, $\exists xy$ un arc dans $C$ où $f(xy)=c(xy)$.\\

\subsubsection{Algorithme}
Pour tout arc $xy$ du graphe $G$: on initialise la valeur du flot de $xy$ à $0$.\\
Tant qu'il existe un plus court chemin améliorant $C$ dans le graphe résiduel de $G$ et $f$:
\begin{itemize}
    \item 
	On détermine le réseau de niveau $N_L$ de $N_f$.
    \item
    Calculer le flot bloquant $f'$ correspondant.
    \item 
    Augmenter $f$ par $f'$
\end{itemize}
Retourner $f$.\\

\subsubsection{Complexité}

\subsubsection{Avantages/inconvénients}

\subsubsection{Application sur l'exemple}
Au début le flot est nul, le réseau résiduel $N_f$ à droite est donc le même que le réseau de flot $N$.\\
Nous avons aussi en dessous, le réseau de niveau $N_L$ :


% --- Deux premiers graphes côte à côte ---
\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		\def\xshift{6}
	
		% --- Graphe 1 ---
		\node[vertex] (S1) at (0.5, 1) {S};
		\node[vertex] (A1) at (2, 2) {A};
		\node[vertex] (B1) at (4, 2) {B};
		\node[vertex] (C1) at (2, 0) {C};
		\node[vertex] (D1) at (4, 0) {D};
		\node[vertex] (P1) at (5.5, 1) {P};
	
		\draw (S1) to node[midway, above left] {4} (A1);
		\draw (S1) to node[midway, below left] {3} (C1);
		\draw (A1) to node[midway, above] {3} (B1);
		\draw (A1) to node[midway, left] {2} (C1);
		\draw (B1) to node[midway, right] {3} (D1);
		\draw (B1) to node[midway, above right] {2} (P1);
		\draw (C1) to node[midway, below] {2} (D1);
		\draw (D1) to node[midway, below left] {1} (A1);
		\draw (D1) to node[midway, below right] {4} (P1);
	
		% --- Graphe 2 ---
		\node[vertex] (S2) at ($(S1)+(\xshift,0)$) {S};
		\node[vertex] (A2) at ($(A1)+(\xshift,0)$) {A};
		\node[vertex] (B2) at ($(B1)+(\xshift,0)$) {B};
		\node[vertex] (C2) at ($(C1)+(\xshift,0)$) {C};
		\node[vertex] (D2) at ($(D1)+(\xshift,0)$) {D};
		\node[vertex] (P2) at ($(P1)+(\xshift,0)$) {P};
	
		\draw (S2) to node[midway, above left] {4} (A2);
		\draw (S2) to node[midway, below left] {3} (C2);
		\draw (A2) to node[midway, above] {3} (B2);
		\draw (A2) to node[midway, left] {2} (C2);
		\draw (B2) to node[midway, right] {3} (D2);
		\draw (B2) to node[midway, above right] {2} (P2);
		\draw (C2) to node[midway, below] {2} (D2);
		\draw (D2) to node[midway, below left] {1} (A2);
		\draw (D2) to node[midway, below right] {4} (P2);
	
	\end{tikzpicture}
	\end{center}
	\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		highlight/.style={->, line width=3pt, draw=yellow},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		\node[vertex] (S3) at (0.5, 1) {S:0};
		\node[vertex] (A3) at (2, 2) {A:1};
		\node[vertex] (B3) at (4, 2) {B:2};
		\node[vertex] (C3) at (2, 0) {C:1};
		\node[vertex] (D3) at (4, 0) {D:2};
		\node[vertex] (P3) at (5.5, 1) {P:3};
	
		\draw (S3) to node[midway, above left] {4} (A3);
		\draw (S3) to node[midway, below left] {3} (C3);
		\draw (A3) to node[midway, above] {3} (B3);
		\draw (B3) to node[midway, right] {2} (P3);
		\draw (C3) to node[midway, below] {2} (D3);
		\draw (D3) to node[midway, below right] {4} (P3);
	
	\end{tikzpicture}
	\end{center}
	



On a donc un chemin améliorant $SABP$ de valeur $2$ ainsi qu'un chemin améliorant $SCDP$ de valeur $2$.

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% Graphe 1
		\node[vertex] (S1) at (0.5, 1) {S};
		\node[vertex] (A1) at (2, 2) {A};
		\node[vertex] (B1) at (4, 2) {B};
		\node[vertex] (C1) at (2, 0) {C};
		\node[vertex] (D1) at (4, 0) {D};
		\node[vertex] (P1) at (5.5, 1) {P};
	
		\draw (S1) -- (A1) node[midway, rectangle, fill=white, above left] {2/4};
		\draw (S1) -- (C1) node[midway, rectangle, fill=white, below left] {2/3};
		\draw (A1) -- (B1) node[midway, rectangle, fill=white, above] {2/3};
		\draw (A1) -- (C1) node[midway, rectangle, fill=white, left] {2};
		\draw (B1) -- (D1) node[midway, rectangle, fill=white, right] {3};
		\draw (B1) -- (P1) node[midway, rectangle, fill=white, above right] {2/2};
		\draw (C1) -- (D1) node[midway, rectangle, fill=white, below] {2/2};
		\draw (D1) -- (A1) node[midway, rectangle, fill=white, below left] {1};
		\draw (D1) -- (P1) node[midway, rectangle, fill=white, below right] {2/4};
	
		% Graphe 2 à droite
		\begin{scope}[xshift=6cm]
			\node[vertex] (S2) at (0.5, 1) {S};
			\node[vertex] (A2) at (2, 2) {A};
			\node[vertex] (B2) at (4, 2) {B};
			\node[vertex] (C2) at (2, 0) {C};
			\node[vertex] (D2) at (4, 0) {D};
			\node[vertex] (P2) at (5.5, 1) {P};
	
			\draw (S2) -- (A2) node[midway, rectangle, fill=white, above left] {2};
			\draw (S2) -- (C2) node[midway, rectangle, fill=white, below left] {1};
			\draw[->, bend left=15] (A2) to node[midway, rectangle, fill=white, above] {1} (B2);
			\draw (A2) -- (C2) node[midway, rectangle, fill=white, left] {2};
			\draw[->, bend left=15] (B2) to node[midway, rectangle, fill=white, below] {2} (A2);
			\draw (B2) -- (D2) node[midway, rectangle, fill=white, right] {3};
			\draw (D2) -- (C2) node[midway, rectangle, fill=white, above] {2};
			\draw (D2) -- (A2) node[midway, rectangle, fill=white, below left] {1};
			\draw (D2) -- (P2) node[midway, rectangle, fill=white, below right] {2};
		\end{scope}
	\end{tikzpicture}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% Graphe 3 seul avec distances
		\node[vertex] (S3) at (0.5, 1) {S:0};
		\node[vertex] (A3) at (2, 2) {A:1};
		\node[vertex] (B3) at (4, 2) {B:2};
		\node[vertex] (C3) at (2, 0) {C:1};
		\node[vertex] (D3) at (4, 0) {D:3};
		\node[vertex] (P3) at (5.5, 1) {P:4};
	
		\draw (S3) -- (A3) node[midway, rectangle, fill=white, above left] {2};
		\draw (S3) -- (C3) node[midway, rectangle, fill=white, below left] {1};
		\draw (A3) -- (B3) node[midway, rectangle, fill=white, above] {1};
		\draw (B3) -- (D3) node[midway, rectangle, fill=white, right] {3};
		\draw (D3) -- (P3) node[midway, rectangle, fill=white, below right] {2};
	\end{tikzpicture}
	\end{center}
	
Nous avons un chemin améliorant $SABDP$ de valeur $1$.

% --- Deux premiers graphes côte à côte ---
\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		\def\xshift{6}
	
		% --- Graphe 1 ---
		\node[vertex] (S1) at (0.5, 1) {S};
		\node[vertex] (A1) at (2, 2) {A};
		\node[vertex] (B1) at (4, 2) {B};
		\node[vertex] (C1) at (2, 0) {C};
		\node[vertex] (D1) at (4, 0) {D};
		\node[vertex] (P1) at (5.5, 1) {P};
	
		\draw (S1) to node[midway, above left] {3/4} (A1);
		\draw (S1) to node[midway, below left] {2/3} (C1);
		\draw (A1) to node[midway, above] {3/3} (B1);
		\draw (A1) to node[midway, left] {2} (C1);
		\draw (B1) to node[midway, right] {1/3} (D1);
		\draw (B1) to node[midway, above right] {2/2} (P1);
		\draw (C1) to node[midway, below] {2/2} (D1);
		\draw (D1) to node[midway, below left] {1} (A1);
		\draw (D1) to node[midway, below right] {3/4} (P1);
	
		% --- Graphe 2 ---
		\node[vertex] (S2) at ($(S1)+(\xshift,0)$) {S};
		\node[vertex] (A2) at ($(A1)+(\xshift,0)$) {A};
		\node[vertex] (B2) at ($(B1)+(\xshift,0)$) {B};
		\node[vertex] (C2) at ($(C1)+(\xshift,0)$) {C};
		\node[vertex] (D2) at ($(D1)+(\xshift,0)$) {D};
		\node[vertex] (P2) at ($(P1)+(\xshift,0)$) {P};
	
		\draw (S2) to node[midway, above left] {1} (A2);
		\draw (S2) to node[midway, below left] {1} (C2);
		\draw (A2) to node[midway, left] {2} (C2);
		\draw (B2) to node[midway, below] {3} (A2);
		\draw[bend left=15] (B2) to node[midway, right] {2} (D2);
		\draw[bend left=15] (D2) to node[midway, left] {1} (B2);
		\draw (D2) to node[midway, above] {2} (C2);
		\draw (D2) to node[midway, below left] {1} (A2);
		\draw (D2) to node[midway, below right] {1} (P2);
	
	\end{tikzpicture}
	\end{center}
	
	% --- Troisième graphe centré ---
	\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		\node[vertex] (S3) at (0.5, 1) {\hspace{0.1cm} S:0 \hspace{0.1cm}};
		\node[vertex] (A3) at (2, 2) {\hspace{0.1cm} A:1 \hspace{0.1cm}};
		\node[vertex] (B3) at (4, 2) {B:$\infty$};
		\node[vertex] (C3) at (2, 0) {\hspace{0.1cm} C:1 \hspace{0.1cm}};
		\node[vertex] (D3) at (4, 0) {D:$\infty$};
		\node[vertex] (P3) at (5.5, 1) {P:$\infty$};
	
		\draw (S3) to node[midway, above left] {1} (A3);
		\draw (S3) to node[midway, below left] {1} (C3);
	
	\end{tikzpicture}
	\end{center}
	

Le puits $P$ n'est plus atteignable, l'algorithme se termine.\\
Finalement la coupe minimale de ce réseau est l'ensemble $\{S,A,C\}$ et son flot maximal est de valeur $5$.\\


%Expliquer pour chaque algo, ce qu'il fait, sa complexité, les avantages/inconvénients et faire un exemple (prendre le même pour tous les algos)
%Faire un graphique qui montre la courbe du temps de calculs de chaque algo en fonction du nombre de sommet
\section{Programmation linéaire}
Nous avons également comparé nos algorithmes avec les meilleurs solveurs de programmation linéaire. Pour cela nous avons utilisé la modélisation standard du problème de flot maximum :
\[
		\begin{aligned}
			\text{Maximiser} \quad &\sum_{v:(s, v)\in E} f(s, v) \\
			\text{Sous les contraintes} \quad
			&
			 \begin{cases}
				\sum_{u:(u, v)\in E} f(u, v) - \sum_{w:(v, w)\in E} f(v, w) = 0 & \forall v \in V \setminus \{s, t\} \\
				f(u, v) \leq c(u, v) & \forall (u, v) \in E \\
				f(u, v) \geq 0 & \forall (u, v) \in E \\
			\end{cases}
		\end{aligned}
\]

La fonction à maximiser est la somme des flots sortants du sommet source $s$, par conservation du flot, c'est aussi égal à la somme des flots entrants dans le sommet puits. La première contrainte assure la conservation du flot pour chaque sommet, sauf pour la source et le puits. La deuxième contrainte assure que le flot sur chaque arête ne dépasse pas sa capacité et la dernière contrainte assure que le flot est positif ou nul.

Une remarque importante est que les variables de flot $f(u, v)$ sont continues, donc a priori, rien n'assure que la solution optimale soit entière.

\subsection{Matrices totalement unimodulaires}
\paragraph{Définition}
Soit $M$ une matrice, on dit qu'elle est totalement unimodulaire si pour toute sous-matrice carrée $N$ de $M$, le déterminant de $N$ est égal à $0$, $1$ ou $-1$.

\paragraph{Théorème (Hoffman \& Kruskal, 1956)} Une matrice entière est totalement unimodulaire si et seulement si le polyhèdre défini par $\{x : Ax \leq b, x \geq 0\}$ est un polyèdre entier pour tout vecteur $b$ entier.


Ce que nous apprend ce théorème, c'est que tout problème linéaire dont la matrice de contraintes est totalement unimodulaire et dont le vecteur de contraintes est entier, a une solution entière.

\paragraph{Théorème} La matrice du problème de flot maximum est totalement unimodulaire.

Et comme le vecteur de contraintes est entier (car les capacités sont entières), la solution optimale est entière.

L'intérêt de ce théorème est que, bien que la programmation linéaire en nombres entiers soit \textsc{NP-complet}, dans le cas du flot maximum, on peut utiliser un solveur de programmation linéaire classique pour obtenir une solution entière.
\subsection{Solveurs de programmation linéaire}
Nous avons utilisé deux solveurs de programmation linéaire : \texttt{Gurobi} et \texttt{GLOP}, ces deux solveurs sont très performants et permettent de résoudre des problèmes de grande taille rapidement.
\section{Création des instances}

Afin de pouvoir tester et comparer nos algorithmes, nous avons eu besoins d'instances de graphe de tailles et de formes differentes afin de pouvoir comparer comment se comportent nos algorithmes. Comme nous n'avons pas trouvé d'instances de graphes suffisamment grandes en ligne, nous avons décidé de créer nos propres instances. Cette partie détaille ce processus de création et présente les differentes instances que nous avons pu créer ainsi que les choix que nous avons faits.

\subsection{La classe RandomFlowNetwork}
Afin de créer un grand nombre d'instances, nous avons du commencé par générer des graphes de manière aléatoire. Pour cela nous avons créé une classe \texttt{RandomFlowNetwork}.\\

Cette classe permet de générer un réseau de flot orienté en plusieurs étapes :

\begin{enumerate}
    \item Elle crée un graphe vide et commence par lui ajouter l'ensemble de ses sommets, chacun identifié par un nom ou un numéro. Le nombre de sommet $n$ crée est controlé à l'avance.
    
    \item Ensuite, elle établit des arêtes orientées entre ces sommets. Ces connexions sont ajoutées de manière aléatoire, tout en respectant certaines contraintes :
    \begin{itemize}
        \item Soit on fixe à l’avance un nombre précis de connexions.
        \item Soit on utilise une densité, c’est-à-dire une proportion du nombre maximal de connexions possibles.
    \end{itemize}
	Ici dans le cas de nos instances, cette derniere méthode est utilisée. Pour expliquer plus clairement comment cela fonctionne, pour un graphe $G=(E,V)$ on pose $d \in [0,1]$ la densité, et ensuite $\forall x, y \in V$ la probabilité d'apparition de l'arête $xy$ est $d$. On essaie donc de créer le graphe complet avec une probabilité $d$ d'apparition sur chaque arêtes.\\
	Nous avons ainsi pu faire varier la densité de nos graphes entre 0.1 et 0.9.\\
    Chaque arête reçoit finalement une capacité aléatoire, c’est-à-dire une valeur représentant sa "capacité" ou "poids".
    
    \item Une fois les arêtes ajoutées, deux sommets distincts sont choisis au hasard : un sommet source (point de départ) et un sommet puits (point d’arrivée).
    
    \item Les arêtes qui partent directement de la source et celles qui arrivent directement au puits sont récupérée et stockées à part.
    
    \item Finalement, le graphe est retourné avec :
    \begin{itemize}
        \item Le sommet source ;
        \item Le sommet puits ;
        \item Les arêtes entre les sommets.
    \end{itemize}
\end{enumerate}

En résumé, cette classe construit un graphe orienté aléatoire, puis désigne deux extrémités pour simuler un réseau de flot. Le problème est le suivant : comment construire des graphes pertinents afin de tester les algorithmes ? 

\subsection{Tests sur les graphes générés}
Les graphes étant générés aléatoirement, on peut obtenir des graphes non connexes, des sommets non reliés à la source ou au puits, etc. Tout cela fausseraient les instances. En effet, si le graphe n’est pas connexe, cela pourrait fausser les résultats : un graphe de taille $1000$ pourrait se résumer à un de taille $100$, ce que l’on ne souhaite pas. On pourrait même tomber sur des graphes où nos algorithmes ne convergeraient pas, par exemple si la source et le puits ne sont pas reliés.\\

On va donc devoir créer un ensemble de tests sur nos graphes afin de s’assurer qu’ils soient bien formés et propices à être utilisées comme instances. Cela pourra prendre du temps car nous générons les graphes aléatoirement et n’en conservons qu’une petite partie, mais ce n’est pas très grave, car le jeu d’instances n’a besoin d’être créé qu’une seule fois. Il n’est pas nécessaire que le code qui permet sa création soit bien optimisé : on le lance un soir et on récupère les instances le lendemain dans le pire des cas.\\

Nous avons donc implémenté une fonction \texttt{IsConnected} qui permet de vérifier les trois critères suivants sur le graphe :
\begin{enumerate}
	\item Depuis la source, on peut atteindre n'importe quel sommet du graphe.
	\item Depuis n'importe quel sommet du graphe, on peut atteindre le puits.
	\item Le graphe est connexe.\\
\end{enumerate}

Cela nous permet de nous assurer que le graphe que nous avons généré est bien formé. En effet, l'algorithme convergera car le premier point nous assure qu'on peut créer un flot sur ce graphe (la source est bien connectée au puits). Les points 2 et 3 nous permettent d'être sûrs que sur un graphe de taille $n$, chaque sommet aura bien son importance et sera bien pris en compte par le calcul. Le graphe ne peut donc pas se résumer à une version plus petite de lui-même.\\

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, minimum size=15pt, inner sep=1pt},
		every edge/.style={->, thick},
		->,>=stealth
		]
	
		% Graphe 1
		\node[vertex] (S1) at (0.5, 1) {S};
		\node[vertex] (A1) at (2, 2) {A};
		\node[vertex] (B1) at (4, 2) {B};
		\node[vertex] (C1) at (2, 0) {C};
		\node[vertex] (D1) at (4, 0) {D};
		\node[vertex] (P1) at (5.5, 1) {P};
		\node (G1) at (3, -1) {Graphe $G$};
	
		\draw (S1) -- (A1) node[midway, above left] {4};
		\draw (S1) -- (C1) node[midway, below left] {3};
		\draw (A1) -- (B1) node[midway, above] {3};
		\draw (C1) -- (A1) node[midway, left] {2};{2};
		\draw (C1) -- (D1) node[midway, below] {2};
		\draw (D1) -- (A1) node[midway, below left] {1};
		\draw (D1) -- (P1) node[midway, below right] {2};
	
		% Graphe 2 à droite
		\begin{scope}[xshift=6cm]
			\node[vertex] (S2) at (0.5, 1) {S'};
			\node[vertex] (A2) at (2, 2) {A'};
			\node[vertex] (B2) at (4, 2) {B'};
			\node[vertex] (C2) at (2, 0) {C'};
			\node[vertex] (D2) at (4, 0) {D'};
			\node[vertex] (P2) at (5.5, 1) {P'};
			\node (G1) at (3, -1) {Graphe $G'$};
	
			\draw (S2) -- (C2) node[midway, below left] {1};
			\draw (A2) -- (B2) node[midway, above] {1};
			\draw (A2) -- (C2) node[midway, left] {2};
			\draw (B2) -- (P2) node[midway, above] {3};
			\draw (C2) -- (B2) node[midway, above] {3};
			\draw (C2) -- (P2) node[midway, above] {3};
		\end{scope}
	\end{tikzpicture}
\end{center}

Ainsi le graphe $G$ ne sera pas pris car on ne peux pas accéder au puit depuis les sommets $A$ et $B$. Le graphe $G'$ quand à lui ne sera pas pris car il n'est pas connexe (le sommet $D'$ est isolé), aussi on ne peux pas accéder au sommet $A'$ depuis la source $S'$. En revanche, le graphe suivant est tout à fait valide :

\begin{center}
	\begin{tikzpicture}[
		vertex/.style={circle, draw, fill=blue!20, inner sep=2pt},
		every edge/.style={draw, ->, thick}, % Ajout de flèches
		->,>=stealth % Style explicite de flèches (stealth' pour une tête nette)
		]
	
		% Les sommets
		\node[vertex] (S) at (0.5, 1) {S};
		\node[vertex] (A) at (2, 2) {A};
		\node[vertex] (B) at (4, 2) {B};
		\node[vertex] (C) at (2, 0) {C};
		\node[vertex] (D) at (4, 0) {D};
		\node[vertex] (P) at (5.5, 1) {P};
			
		% Les arêtes orientées
		%\draw[->, bend left=15] (A) to (B);
		\draw[->] (S) to node[midway, above left] {4} (A);
		\draw[->] (S) to node[midway, below left] {3} (C);
		\draw[->] (A) to node[midway, above] {3} (B);
		\draw[->] (A) to node[midway, left] {2} (C);
		\draw[->] (B) to node[midway, right] {3} (D);
		\draw[->] (B) to node[midway, above right] {2} (P);
		\draw[->] (C) to node[midway, below] {2} (D);
		\draw[->] (D) to node[midway, below left] {1} (A);
		\draw[->] (D) to node[midway, below right] {4} (P);
	\end{tikzpicture}
\end{center}

Nous avons ainsi pu créer un jeu d’instances complet. Afin de généraliser davantage et de mieux comparer les résultats, plusieurs instances similaires (ayant la même taille et la même densité) sont créées. Pour connaître l’efficacité d’un algorithme sur une instance de ce type, on peut ainsi faire la moyenne des performances sur l’ensemble des instances de même taille et même densité.

\subsection{Représentation des instances}

Nous avons décidé de représenter les instances sous forme de fichiers texte. Chaque instance est représentée par un fichier contenant les informations suivantes :\\

\begin{itemize}
	\item Le numéro de la source ;
	\item Le numéro du puits ;
	\item La liste des arcs du graphe, sous la forme : $x\ y\ c(xy)$ où $x$ et $y$ sont les numéros des sommets de l’arc, et $c(xy)$ est la capacité de l’arc.\\
\end{itemize}

Le nombre de sommets ainsi que la densité du graphe sont indiqués dans le nom du fichier. Par exemple, voici les premières lignes du fichier \texttt{inst30\_0,1\_1}, où $30$ représente le nombre de sommets, $0{,}1$ la densité, et $1$ le numéro de l’instance (car plusieurs instances sont créées pour un même nombre de sommets et une même densité).\\

\begin{center}
\noindent
\begin{minipage}{0.6\linewidth}  % Réduit la largeur du bloc
\begin{lstlisting}
	22
	4
	17 21 9
	24 25 8
	12 27 55
	...
\end{lstlisting}
\end{minipage}
\end{center}

\subsection{Les instances choisies}

Nous avons créé des instances pour toutes les tailles multiples de $10$ entre $30$ et $200$. Pour chaque taille, nous avons utilisé trois densités : $0{,}1$, $0{,}5$ et $0{,}9$. Pour chaque densité, trois instances différentes ont été générées. Cela représente au total plus de $150$ instances pour tester nos programmes.
Nous avons choisi de rester sur des tailles raisonnables afin que tous les algorithmes, même les moins efficaces, puissent toujours converger et ainsi être comparés. En effet, pour un graphe de taille de $200$ sommets et une densité de $0{,}9$, on obtient en moyenne :

\begin{center}
$\frac{200 \times (200-1)}{2} \times 2 \times 0{,}9 = 35 820$ arêtes
\end{center}

Le $\frac{200 \times (200-1)}{2} \times 2$ correspondant à toutes les arêtes possibles. En effet $\frac{n \times (n-1)}{2}$ pour le graphe complet, $\times 2$ car les arêtes sont orientés. On multiplie par la densité pour savoir le nombre d'arête en moyenne, dans notre exemple la densité est de $0,9$.


\end{document}

